#ifndef MYBUGREPORTER_H
#define MYBUGREPORTER_H

#include "clang/StaticAnalyzer/Core/BugReporter/BugReporter.h"
#include "clang/StaticAnalyzer/Core/BugReporter/BugReporterVisitor.h"
#include "clang/StaticAnalyzer/Core/BugReporter/PathDiagnostic.h"

namespace clang {
	namespace ento {
		// reimplment BugReporter to summarize multiple reports into one at checkEndAnalysis
		// The original BugReporter calls FlushReports() at its destructor, so we need to reimplement it.

		class MyBugReportEquivClass : public llvm::FoldingSetNode {
			/// List of *owned* BugReport objects.
			llvm::ilist<BugReport> Reports;

			friend class MyBugReporter;
			void AddReport(std::unique_ptr<BugReport> R) {
				Reports.push_back(R.release());
			}

		public:
			MyBugReportEquivClass(std::unique_ptr<BugReport> R) { AddReport(std::move(R)); }
			~MyBugReportEquivClass() {}

			void Profile(llvm::FoldingSetNodeID& ID) const {
				assert(!Reports.empty());
				Reports.front().Profile(ID);
			}

			typedef llvm::ilist<BugReport>::iterator iterator;
			typedef llvm::ilist<BugReport>::const_iterator const_iterator;

			iterator begin() { return Reports.begin(); }
			iterator end() { return Reports.end(); }

			const_iterator begin() const { return Reports.begin(); }
			const_iterator end() const { return Reports.end(); }
		};

		/// BugReporter is a utility class for generating PathDiagnostics for analysis.
		/// It collects the BugReports and BugTypes and knows how to generate
		/// and flush the corresponding diagnostics.
		class MyBugReporter {
		public:
			enum Kind { BaseBRKind, GRBugReporterKind };

		private:
			typedef llvm::ImmutableSet<BugType*> BugTypesTy;
			BugTypesTy::Factory F;
			BugTypesTy BugTypes;

			const Kind kind;
			BugReporterData& D;

			ExprEngine& Eng;

			/// Generate and flush the diagnostics for the given bug report.
			void FlushReport(MyBugReportEquivClass& EQ);

			/// Generate and flush the diagnostics for the given bug report
			/// and PathDiagnosticConsumer.
			void FlushReport(BugReport *exampleReport,
				PathDiagnosticConsumer &PD,
				ArrayRef<BugReport*> BugReports);

			/// The set of bug reports tracked by the BugReporter.
			llvm::FoldingSet<MyBugReportEquivClass> EQClasses;
			/// A vector of BugReports for tracking the allocated pointers and cleanup.
			std::vector<MyBugReportEquivClass *> EQClassesVector;

		protected:
			MyBugReporter(BugReporterData& d, ExprEngine& eng, Kind k) : BugTypes(F.getEmptySet()), kind(k),
				D(d), Eng(eng) {}

		public:
			MyBugReporter(BugReporterData& d, ExprEngine& eng) : BugTypes(F.getEmptySet()), kind(BaseBRKind),
				D(d), Eng(eng) {}
			virtual ~MyBugReporter();

			/// \brief Generate and flush diagnostics for all bug reports.
			void FlushReports();

			Kind getKind() const { return kind; }

			DiagnosticsEngine& getDiagnostic() {
				return D.getDiagnostic();
			}

			ArrayRef<PathDiagnosticConsumer*> getPathDiagnosticConsumers() {
				return D.getPathDiagnosticConsumers();
			}

			/// \brief Iterator over the set of BugTypes tracked by the BugReporter.
			typedef BugTypesTy::iterator iterator;
			iterator begin() { return BugTypes.begin(); }
			iterator end() { return BugTypes.end(); }

			/// \brief Iterator over the set of BugReports tracked by the BugReporter.
			typedef llvm::FoldingSet<MyBugReportEquivClass>::iterator EQClasses_iterator;
			EQClasses_iterator EQClasses_begin() { return EQClasses.begin(); }
			EQClasses_iterator EQClasses_end() { return EQClasses.end(); }

			ASTContext &getContext() { return D.getASTContext(); }

			SourceManager& getSourceManager() { return D.getSourceManager(); }

			AnalyzerOptions& getAnalyzerOptions() { return D.getAnalyzerOptions(); }

			bool generatePathDiagnostic(PathDiagnostic& pathDiagnostic,
				PathDiagnosticConsumer &PC,
				ArrayRef<BugReport *> &bugReports);

			void Register(BugType *BT);

			/// \brief Add the given report to the set of reports tracked by BugReporter.
			///
			/// The reports are usually generated by the checkers. Further, they are
			/// folded based on the profile value, which is done to coalesce similar
			/// reports.
			void emitReport(BugReport *R);

			/// getEngine - Return the analysis engine used to analyze a given
			///  function or method.
			ExprEngine &getEngine() { return Eng; }

			/// getGraph - Get the exploded graph created by the analysis engine
			///  for the analyzed method or function.
			ExplodedGraph &getGraph();

			/// getStateManager - Return the state manager used by the analysis
			///  engine.
			ProgramStateManager &getStateManager();


			GRBugReporter toGRBugReporter() {
				return GRBugReporter(D, Eng);
			}
		};
	}
}

#endif